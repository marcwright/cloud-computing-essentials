# ![](https://ga-dash.s3.amazonaws.com/production/assets/logo-9f88ae6c9c3871690e33280fcf557f33.png) How To Dockerize

### Learning Objectives

- Why is Docker Compose used?
- Explain Docker Compose
- Understand how it works?
- Learn Docker Compose commands

## Lesson Overview 

| Topic | Type | Timing |
| --- | --- | -- |
| Dockerfile     | Lecture | 20 min |
| Docker Volumes       | Lecture | 15 min |
| Activity: Dockerfile | Exercise | 15 min |
| Push Image to Docker Hub | Exercise | 50 min |

![](https://www.memecreator.org/static/images/memes/5099940.jpg)

## Dockerfile (20 min)

So far we have used an existing image to run a container, even deployed it on a cloud platform. But we haven't talked about how to create an image or like people say dockerize our app.

According to [docs](https://docs.docker.com/engine/reference/builder/#:~:text=A%20Dockerfile%20is%20a%20text,command%2Dline%20instructions%20in%20succession.), a **Dockerfile** is a text document that contains all the commands a user could call on the command line to assemble an image. It is used by docker to build images automatically by reading instructions from it.

You can specify details like, the OS, languages, etc. Explain what the container will do when it's run. You can create your own or use premade ones.

If what we did earlier, copying our `JavaWebApp.war` to tomcat webserver in order to deploy it, we could have done the same thing using a `Dockerfile`. It would have looked something like,

```
FROM tomcat:8.0-alpine

LABEL maintainer=”isha.arora@generalassemb.ly”

ADD JavaWebApp.war /usr/local/tomcat/webapps/

EXPOSE 8080

CMD [“catalina.sh”, “run”]
```
Dockerfile is named as just `Dockerfile`. It is case-sensitive and without any extension.

Lets go over what the above instructions mean,

- The `FROM` instruction initializes a new build stage and sets the base image for subsequent instructions. So in this case we are using tomcat image.
- The `LABEL` instruction sets the Author field of the generated images. You could use any key-value pair in labels.
- The `ADD` instruction copies new files, directories or remote file URLs from <src> and adds them to the filesystem of the image at the path <dest>.
- The `EXPOSE` instruction informs Docker that the container listens on the specified network ports at runtime.
- The `CMD` instruction specifies what to run when the container (not the image) is run. In our case, Tomcat server is started by running the shell script that starts the web container. There can only be one `CMD` instruction in a `Dockerfile`.

There are lot of other instructions you can have in a Dockerfile. We will go over some of them as needed.

### Lets Discuss

Lets draw parallels with how we manually deployed `JavaWebApp` on Tomcat and what the instructions in the `Dockerfile` given above say. 


## Docker Volumes (15 min)

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. When you use a volume, a new directory is created within Docker’s storage directory on the host machine, and Docker manages that directory’s contents.

Volumes have several advantages,

- You can manage volumes using Docker CLI commands or the Docker API.
- Volumes work on both Linux and Windows containers.
- Volumes can be more safely shared among multiple containers.
- New volumes can have their content pre-populated by a container.

You can create and manage volumes outside the scope of any container.

#### Create a volume

`docker volume create new-vol`

#### List volumes

```
$ docker volume ls
local     new-vol
```
> You may see some random volumes listed, those are created by docker.

#### Inspect a volume

```
$ docker volume inspect my-vol
[
    {
        "CreatedAt": "2021-04-22T17:49:18Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/new-vol/_data",
        "Name": "new-vol",
        "Options": {},
        "Scope": "local"
    }
]
```

#### Remove a volume:

`docker volume rm new-vol`

### Start a container with a volume

You can start a container with a new or existing volume. Run,

`docker run --name test-vol -v new-vol hello-world`
> As name implies `--name` is used to assign name to the container.

Now run `docker inspect test-vol`. You will see lot on the output, look for *Mounts* section.

```
"Mounts": [
            {
                "Type": "volume",
                "Name": "6e0e215327c8497ac2f08fe4ca57b939eef7737e851b5e9b368f943d6a284a3b",
                "Source": "/var/lib/docker/volumes/6e0e215327c8497ac2f08fe4ca57b939eef7737e851b5e9b368f943d6a284a3b/_data",
                "Destination": "new-vol",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ]
```
This shows that the mount is a volume, it shows the correct source and destination, and that the mount is read-write.

## Activity: Dockerfile (15 min)

In a group of 2-4 look at the Dockerfile of the `springboot-chat-app` we deployed to heroku earlier. You can find the file [here](./resources/springboot-chat-app/Dockerfile).

```
# Start with a base image containing Java runtime:
FROM openjdk:8-jdk-alpine

# Add Maintainer info:
MAINTAINER GA <admin@xyz.com>

# Add a volume pointing to /tmp:
VOLUME /tmp

# Make port 80 available to the world outside this container:
EXPOSE 80

# The application's JAR file:
ARG JAR_FILE=target/websocket-demo-0.0.1-SNAPSHOT.jar

# Add the application's JAR to the container:
ADD ${JAR_FILE} websocket-demo.jar

# Run the jar file:
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/websocket-demo.jar"]
``` 

Look at each instruction and try to understand each as a group and if you could have done anything differently

<details>
<summary>What's Going on Here?</summary>

`FROM`: A Docker image can use another image available in the Docker registry as its base or parent image. In the example above, we use the `openjdk:8-jdk-alpine` image as our base image.

`MAINTAINER`: The `MAINTAINER` instruction is used to add metadata to the image. In the Dockerfile above, we've added some info about the maintainer of the image.

`VOLUME`: In the Dockerfile above, we created a mount point with path `/tmp` because this is where the Spring Boot application creates working directories for Tomcat by default. But, if you want to store stuff such as Tomcat access logs, then VOLUMEs are very useful.

`EXPOSE`: As the name suggests, this instruction allows you to expose a certain port to the outside world.

`ARG`: The `ARG` instruction defines a variable with a default value. You can override the default value of the variable by passing it at build time.

`ADD`: The `ADD` instruction is used to copy new files and directories to the Docker image.

`ENTRYPOINT`: This is where you configure how the application is executed inside the container.
</details>

**Interestingly**, in the previous Dockerfile we used `CMD` to give the command of how to run the container and here we used `ENTRYPOINT`. There is a small but significant difference between the two. If you want to specify default arguments and want it to be overwritten on specifying CLI arguments, use `CMD` commands. And if you want to run a container with the condition that a particular command is always executed, use `ENTRYPOINT`.

## Code Along: Push Image to Docker Hub (50 min)

![](https://media.giphy.com/media/fBDHRZj2BPDcu9yFBj/giphy.gif)

We are now going to use another sample app. This is a [Node.js](https://nodejs.org/en/) application used to display Pokemon. 

Checkout the [sample app](./resources/pokemon-app).

`cd ./resources/node-pokemon-app`

### Create Dockerfile

We will define the Docker image and specify all of the configurations required to run the app in the Dockerfile.

Under root directory `node-pokemon-app` create Dockerfile `touch Dockerfile`.

Open the `Dockerfile` and paste the instructions given below,

```
FROM node:14

MAINTAINER GA <admin@xyz.com>

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3000

CMD [ "node", "server.js" ]
```

**Alright, what's happening here?** 
> Discuss before going through it.

- Each Dockerfile must begin with a `FROM` instruction. Here we are using the latest version of node available in docker hub.
- `WORKDIR` is used to create a directory to hold the application code inside the image, this will be the working directory for your application. If a `WORKDIR` isn’t set, Docker will create one by default.
- Next, `COPY` the `package.json` and `package-lock.json` files. This file holds various metadata relevant to the project. It is used to handle the project's dependencies.
- `RUN npm install` will install all the dependencies required by the app.
- Last `COPY . .` is used to bundle your app's source code inside the Docker image. This is specific to Nodejs app.
- App binds to port `3000` so `EXPOSE` instruction is used to have it mapped by the docker daemon.
- `CMD` defined the command `node server.js` to start the server.

### .dockerignore

`.dockerignore` prevents local modules and debug logs from being copied onto your Docker image and possibly overwriting modules installed within your image.

Create a `.dockerignore` file in the same directory as your Dockerfile with following content,

```
node_modules
npm-debug.log
```

### Building the docker image

When we try to build an image using dockerfile, the instructions are executed step by step. Make sure you are in directory `node-pokemon-app` then run command

`docker build -t node-pokemon-app .`

List the newly created docker image.

```
$ docker images
REPOSITORY                                       TAG               IMAGE ID       CREATED         SIZE
node-pokemon-app                                 latest            a4d051236343   30 hours ago    129MB
```

### Publish to Docker Hub

If we want our Docker image to be available for others to download and consume, we need to push it to the Docker Hub.

However, before you can push anything to Docker Hub, you need to login. 

#### Docker Login

Run `docker login` on the terminal. Enter the same username and password you used to create account on docker hub.

#### Tag image

To push a local image to the Docker registry, you need to associate the local image with a repository on the Docker registry. The notation for the repository on the Docker registry is `<username>/<repository>:<tag>`.

`$ docker tag node-pokemon-app <username>/node-pokemon-app:latest`
> Replace `<username>` with your docker username
> This command will create a new repository called `node-pokemon-app` in your docker account. 

Verify that the tagged image shows up with the following command:

```
$ docker images
REPOSITORY                                       TAG               IMAGE ID       CREATED         SIZE
<username>/node-pokemon-app                     latest            a4d051236343   30 hours ago    129MB
```

#### Test the image

Run `docker run -p 5000:3000 -d <username>/node-pokemon-app`

Open [http://localhost:5000](http://localhost:5000/) to test if the image is working. You can even check the logs if you want.

#### Push image to Docker Hub

Finally, we push the image to the Docker Hub with the `docker push` command.

```
$ docker push <username>/node-pokemon-app:latest
The push refers to repository [docker.io/<username>/node-pokemon-app]
latest: digest: sha256:73b1ecebcf4940ea319899b62f1c96fae34657c02841939a44ff6c8c46a63746 size: 1159
```

You can view the image [here](https://hub.docker.com/repositories) in your docker hub account.

That's it! You are all done
